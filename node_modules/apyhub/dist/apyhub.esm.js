import fetch, { Request } from 'cross-fetch';
import FormData from 'form-data';
import { readFileSync, writeFile } from 'fs';
import { resolve, basename } from 'path';

function _regeneratorRuntime() {
  _regeneratorRuntime = function () {
    return exports;
  };
  var exports = {},
    Op = Object.prototype,
    hasOwn = Op.hasOwnProperty,
    defineProperty = Object.defineProperty || function (obj, key, desc) {
      obj[key] = desc.value;
    },
    $Symbol = "function" == typeof Symbol ? Symbol : {},
    iteratorSymbol = $Symbol.iterator || "@@iterator",
    asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
    toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }
  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }
  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
      generator = Object.create(protoGenerator.prototype),
      context = new Context(tryLocsList || []);
    return defineProperty(generator, "_invoke", {
      value: makeInvokeMethod(innerFn, self, context)
    }), generator;
  }
  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }
  exports.wrap = wrap;
  var ContinueSentinel = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
    NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }
  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if ("throw" !== record.type) {
        var result = record.arg,
          value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }
      reject(record.arg);
    }
    var previousPromise;
    defineProperty(this, "_invoke", {
      value: function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(innerFn, self, context) {
    var state = "suspendedStart";
    return function (method, arg) {
      if ("executing" === state) throw new Error("Generator is already running");
      if ("completed" === state) {
        if ("throw" === method) throw arg;
        return doneResult();
      }
      for (context.method = method, context.arg = arg;;) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }
        if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
          if ("suspendedStart" === state) throw state = "completed", context.arg;
          context.dispatchException(context.arg);
        } else "return" === context.method && context.abrupt("return", context.arg);
        state = "executing";
        var record = tryCatch(innerFn, self, context);
        if ("normal" === record.type) {
          if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
          return {
            value: record.arg,
            done: context.done
          };
        }
        "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
      }
    };
  }
  function maybeInvokeDelegate(delegate, context) {
    var methodName = context.method,
      method = delegate.iterator[methodName];
    if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }
  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }
  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }
  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;
      if (!isNaN(iterable.length)) {
        var i = -1,
          next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
            return next.value = undefined, next.done = !0, next;
          };
        return next.next = next;
      }
    }
    return {
      next: doneResult
    };
  }
  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), defineProperty(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (val) {
    var object = Object(val),
      keys = [];
    for (var key in object) keys.push(key);
    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;
      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
          record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");
        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
            hasFinally = hasOwn.call(entry, "finallyLoc");
          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }
      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ApyClient = /*#__PURE__*/function () {
  function ApyClient(apyToken, options) {
    var _options$debug, _options$rateLimit;
    this.baseUrl = "https://api.apyhub.com";
    this.headers = typeof apyToken === "string" ? {
      "apy-token": apyToken
    } : typeof apyToken === "object" && apyToken.username && apyToken.password && {
      Authorization: "Basic " + Buffer.from(apyToken.username + ":" + apyToken.password).toString("base64")
    };
    this.debug = (_options$debug = options == null ? void 0 : options.debug) != null ? _options$debug : false;
    this.requestQueue = [];
    this.rateLimit = (_options$rateLimit = options == null ? void 0 : options.rateLimit) != null ? _options$rateLimit : 1;
    this.rateLimitPeriod = 1000; // Set the rate limit period to 1 second (1000 milliseconds)
    this.rateLimitTimer = null;
    this.requestPromises = [];
  }
  var _proto = ApyClient.prototype;
  _proto.debugRequest = function debugRequest(method, url, data) {
    var request = new Request(url, {
      method: method,
      headers: this.headers,
      body: data
    });
    console.log(request);
  };
  _proto.request = /*#__PURE__*/function () {
    var _request = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(method, url, data, options) {
      var _this = this;
      var headers, requestPromise;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (options === void 0) {
                options = {};
              }
              if (!(!this.headers["apy-token"] && !this.headers["Authorization"])) {
                _context.next = 3;
                break;
              }
              throw new Error("Basic Authorization or Token is required");
            case 3:
              headers = _extends({}, this.headers, options.headers);
              if (this.debug) {
                this.debugRequest(method, url, data);
              }
              // Push the request to the request queue
              this.requestQueue.push({
                method: method,
                url: url,
                data: data,
                headers: headers
              });
              // Create a new promise to store the request response
              requestPromise = new Promise(function (resolve) {
                // Push the promise to the requestPromises array
                _this.requestPromises.push(resolve);
              }); // Check if the rate limit timer is running
              if (!this.rateLimitTimer) {
                _context.next = 11;
                break;
              }
              _context.next = 10;
              return requestPromise;
            case 10:
              return _context.abrupt("return", _context.sent);
            case 11:
              // Start the rate limiter
              this.startRateLimiter();
              _context.next = 14;
              return requestPromise;
            case 14:
              return _context.abrupt("return", _context.sent);
            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    function request(_x, _x2, _x3, _x4) {
      return _request.apply(this, arguments);
    }
    return request;
  }();
  _proto.startRateLimiter = function startRateLimiter() {
    var _this2 = this;
    // Start the rate limit timer
    this.rateLimitTimer = setTimeout(function () {
      // Reset the timer
      _this2.rateLimitTimer = null;
      // Process the request queue
      void _this2.processRequestQueue();
    }, this.rateLimitPeriod);
  };
  _proto.processRequestQueue = /*#__PURE__*/function () {
    var _processRequestQueue = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var requests, i, request, response;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              // Take the first n requests from the queue, where n is the rate limit
              requests = this.requestQueue.splice(0, this.rateLimit); // Process the requests
              i = 0;
            case 2:
              if (!(i < requests.length)) {
                _context2.next = 31;
                break;
              }
              request = requests[i];
              _context2.prev = 4;
              response = void 0;
              _context2.t0 = request.method;
              _context2.next = _context2.t0 === "get" ? 9 : _context2.t0 === "post" ? 13 : 17;
              break;
            case 9:
              _context2.next = 11;
              return fetch(request.url, {
                method: "GET",
                headers: request.headers
              });
            case 11:
              response = _context2.sent;
              return _context2.abrupt("break", 17);
            case 13:
              _context2.next = 15;
              return fetch(request.url, {
                method: "POST",
                headers: request.headers,
                body: request.data instanceof FormData ? request.data : JSON.stringify(request.data)
              });
            case 15:
              response = _context2.sent;
              return _context2.abrupt("break", 17);
            case 17:
              _context2.t1 = this.requestPromises;
              _context2.t2 = i;
              _context2.next = 21;
              return this.handleResponse(response);
            case 21:
              _context2.t3 = _context2.sent;
              _context2.t1[_context2.t2].call(_context2.t1, _context2.t3);
              _context2.next = 28;
              break;
            case 25:
              _context2.prev = 25;
              _context2.t4 = _context2["catch"](4);
              // Reject the corresponding request promise with the error message
              this.requestPromises[i](Promise.reject(_context2.t4));
            case 28:
              i++;
              _context2.next = 2;
              break;
            case 31:
              // Clear the requestPromises array
              this.requestPromises = [];
              // Check if there are any more requests in the queue
              if (this.requestQueue.length > 0) {
                // If there are more requests, start the rate limiter again
                this.startRateLimiter();
              }
            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this, [[4, 25]]);
    }));
    function processRequestQueue() {
      return _processRequestQueue.apply(this, arguments);
    }
    return processRequestQueue;
  }();
  _proto.handleResponse = /*#__PURE__*/function () {
    var _handleResponse = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(response) {
      var _response$headers$get;
      var error, errorCode, contentType, blobTypes, handleBlob, handleText, handleJson;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (this.debug) {
                console.log(response);
              }
              if (response.ok) {
                _context6.next = 7;
                break;
              }
              _context6.next = 4;
              return response.text();
            case 4:
              error = _context6.sent;
              errorCode = response.status;
              throw new Error(errorCode + ": " + error);
            case 7:
              contentType = (_response$headers$get = response.headers.get("Content-Type")) != null ? _response$headers$get : "";
              blobTypes = new Set(["image/png", "image/jpeg", "application/zip", "application/pdf"]);
              handleBlob = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(responseData) {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          _context3.next = 2;
                          return responseData.blob();
                        case 2:
                          return _context3.abrupt("return", _context3.sent);
                        case 3:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3);
                }));
                return function handleBlob(_x6) {
                  return _ref.apply(this, arguments);
                };
              }();
              handleText = /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(responseData) {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          _context4.next = 2;
                          return responseData.text();
                        case 2:
                          return _context4.abrupt("return", _context4.sent);
                        case 3:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _callee4);
                }));
                return function handleText(_x7) {
                  return _ref2.apply(this, arguments);
                };
              }();
              handleJson = /*#__PURE__*/function () {
                var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(responseData) {
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return responseData.json();
                        case 2:
                          return _context5.abrupt("return", _context5.sent);
                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, _callee5);
                }));
                return function handleJson(_x8) {
                  return _ref3.apply(this, arguments);
                };
              }();
              _context6.t0 = true;
              _context6.next = _context6.t0 === contentType.includes("text/plain") ? 15 : _context6.t0 === contentType.includes("text/html") ? 15 : 18;
              break;
            case 15:
              _context6.next = 17;
              return handleText(response);
            case 17:
              return _context6.abrupt("return", _context6.sent);
            case 18:
              if (!blobTypes.has(contentType)) {
                _context6.next = 24;
                break;
              }
              _context6.next = 21;
              return handleBlob(response);
            case 21:
              _context6.t1 = _context6.sent;
              _context6.next = 27;
              break;
            case 24:
              _context6.next = 26;
              return handleJson(response);
            case 26:
              _context6.t1 = _context6.sent;
            case 27:
              return _context6.abrupt("return", _context6.t1);
            case 28:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
    function handleResponse(_x5) {
      return _handleResponse.apply(this, arguments);
    }
    return handleResponse;
  }();
  return ApyClient;
}();
var instance = null;
// getInstance with ApyClientParams
function getInstance(apyToken, options) {
  if (!instance) {
    if (!apyToken) {
      throw new Error("Basic Authorization or Token is required");
    }
    instance = new ApyClient(apyToken, options);
  }
  return instance;
}
/**
 * Initializes the Apyhub API client.
 *
 * @param {string} apyToken - The Apyhub API token or Basic Authorization
 *   credentials.
 * @param {Object} [options] - Options for the API client.
 * @param {1 | 2 | 3 | 4 | 5} [options.rateLimit] - The rate limit for the API
 *   client.
 */
function initApyhub(apyToken, options) {
  getInstance(apyToken, options);
}

/**
 * Fuzzy search.
 *
 * @example
 *   const { search } = require("apyhub");
 *
 *   const fuzzy = async () => {
 *     const data = await search.fuzzy({
 *       source: "taching",
 *       target: "teaching is the best qualifying compare another profession",
 *       unicodeNormalized: false,
 *     });
 *     return data;
 *   };
 *
 * @param {Object} options - The options for the function.
 * @param {string} options.source - The source text.
 * @param {string} options.target - The target text.
 * @param {boolean} [options.unicodeNormalized] - Whether the text is unicode
 *   normalized. Default is false.
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves to
 *   an object with the fuzzy search result, or undefined if the response format
 *   is invalid.
 * @link https://apyhub.com/utility/search-fuzzy-text
 */
function fuzzy(_x) {
  return _fuzzy.apply(this, arguments);
}
function _fuzzy() {
  _fuzzy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var source, target, _ref$unicodeNormalize, unicodeNormalized, client, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            source = _ref.source, target = _ref.target, _ref$unicodeNormalize = _ref.unicodeNormalized, unicodeNormalized = _ref$unicodeNormalize === void 0 ? false : _ref$unicodeNormalize;
            client = getInstance();
            requestUrl = "https://api.apyhub.com/search/text/fuzzy?unicode-normalized=" + unicodeNormalized.toString(); // return empty array if source or target is empty string
            if (!(!source || !target)) {
              _context.next = 5;
              break;
            }
            return _context.abrupt("return", {
              data: []
            });
          case 5:
            _context.next = 7;
            return client.request("post", requestUrl, {
              source: source,
              target: target
            }, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fuzzy.apply(this, arguments);
}



var index = {
  __proto__: null,
  fuzzy: fuzzy
};

var checkMissingParams = function checkMissingParams(params) {
  var missingParams = Object.entries(params).filter(function (_ref) {
    var value = _ref[1];
    return !value;
  });
  if (missingParams.length > 0) {
    var errorMessage = "Missing parameters: " + missingParams.map(function (_ref2) {
      var key = _ref2[0];
      return key;
    }).join(", ");
    throw new Error(errorMessage);
  }
};

var checkParamTypes = function checkParamTypes(params, values) {
  // check if the `values` parameter is a string or an array of strings
  var stringValues = typeof values === "string" ? [values] : values;
  // check if all the values in `params` are strings and are equal to one of the values in `values`
  var invalidParams = Object.entries(params).filter(function (_ref) {
    var value = _ref[1];
    return typeof value !== "string" || !stringValues.includes(value);
  });
  if (invalidParams.length > 0) {
    var errorMessage = "Invalid parameters: " + invalidParams.map(function (_ref2) {
      var key = _ref2[0];
      return key;
    }).join(", ") + ". \nSupported values are: " + stringValues.join(", ");
    throw new Error(errorMessage);
  }
};

/**
 * Validates an email address.
 *
 * @example
 *   const { validate } = require("apyhub");
 *
 *   const email = async () => {
 *     const data = await validate.email({
 *       email: "hello@apyhub.com",
 *       checkType: "dns",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} options - The options for the function.
 * @param {string} options.email - The email address to validate.
 * @param {"dns" | "academic"} options.checkType - The type of validation to
 *   perform. Can be either "dns" or "academic".
 * @returns {Promise<{ data: boolean }>} - A promise that resolves to an object
 *   with the validation result.
 * @link https://apyhub.com/utility/validator-dns-email
 * @link https://apyhub.com/utility/validator-academic-email
 */
function email(_x) {
  return _email.apply(this, arguments);
}
function _email() {
  _email = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var email, checkType, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            email = _ref.email, checkType = _ref.checkType;
            client = getInstance();
            checkMissingParams({
              email: email,
              checkType: checkType
            });
            checkParamTypes({
              checkType: checkType
            }, ["dns", "academic"]);
            url = "https://api.apyhub.com/validate/email/" + checkType;
            _context.next = 7;
            return client.request("post", url, {
              email: email
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _email.apply(this, arguments);
}

// generate jsdocs for the postcode validator
/**
 * Validates a postcode.
 *
 * @example
 *   const { validate } = require("apyhub");
 *
 *   const validatePostcode = async () => {
 *     const data = await validate.postcode({
 *       postcode: "560037",
 *       countryCode: "in",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} options - The options for the function.
 * @param {string} options.postcode - The postcode to validate.
 * @param {"in" | "uk"} options.countryCode - The country code of the postcode.
 *   Can be either "in" or "uk".
 * @returns {Promise<{ data: boolean }>} - A promise that resolves to an object
 *   with the validation result.
 * @link https://apyhub.com/utility/data-postcodes-india
 * @link https://apyhub.com/utility/data-postcodes-uk
 */
function postcode(_x) {
  return _postcode.apply(this, arguments);
}
function _postcode() {
  _postcode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var postcode, countryCode, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            postcode = _ref.postcode, countryCode = _ref.countryCode;
            client = getInstance();
            checkMissingParams({
              postcode: postcode,
              countryCode: countryCode
            });
            checkParamTypes({
              countryCode: countryCode.toLowerCase()
            }, ["in", "uk"]);
            url = "https://api.apyhub.com/validate/postcodes/" + countryCode.toLowerCase();
            _context.next = 7;
            return client.request("post", url, {
              postcode: postcode
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _postcode.apply(this, arguments);
}

// generate jsdocs for the vat validator
/**
 * Validates a VAT number.
 *
 * @example
 *   const { validate } = require("apyhub");
 *
 *   const validateVat = async () => {
 *     const data = await validate.vat({
 *       vat: "GB123456789",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} options - The options for the function.
 * @param {string} options.vat - The VAT number to validate.
 * @returns {Promise<{ data: boolean }>} - A promise that resolves to an object
 *   with the validation result.
 * @link https://apyhub.com/utility/vat-number-validator
 */
function vat(_x) {
  return _vat.apply(this, arguments);
}
function _vat() {
  _vat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(vat) {
    var client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            checkMissingParams({
              vat: vat
            });
            url = "https://api.apyhub.com/validate/vat";
            _context.next = 5;
            return client.request("post", url, {
              vat: vat
            });
          case 5:
            return _context.abrupt("return", _context.sent);
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _vat.apply(this, arguments);
}



var index$1 = {
  __proto__: null,
  email: email,
  postcode: postcode,
  vat: vat
};

function getFileExtension(buffer) {
  // Check for the various file types we support.
  if (buffer.slice(0, 4).toString() === "%PDF") {
    return "pdf";
  } else if (buffer.slice(0, 2).toString() === "PK") {
    return "docx";
  } else if (buffer.slice(0, 2).toString() === "PK") {
    return "pptx";
  } else if (buffer.slice(0, 2).toString() === "PK") {
    return "xlsx";
  } else if (buffer.slice(0, 5).toString() === "<html") {
    return "html";
  } else if (buffer.slice(0, 3).toString() === "---") {
    return "md";
  } else if (buffer.slice(0, 2).toString() === "BM") {
    return "jpg";
  } else if (buffer.slice(0, 3).toString() === "GIF") {
    return "jpg";
  } else if (buffer.slice(0, 3).toString() === "PNG") {
    return "jpg";
  } else if (buffer.slice(0, 4).toString() === "\x89PNG") {
    return "jpg";
  } else if (buffer.slice(0, 4).toString() === "\xff\xd8\xff\xe0") {
    return "jpg";
  } else if (buffer.slice(0, 4).toString() === "\xff\xd8\xff\xe1") {
    return "jpg";
  } else if (buffer.slice(0, 4).toString() === "ID\x01\x02") {
    return "csv";
  }
  // If the file type isn't recognized, return null.
  return null;
}

function getFormData(file, fieldName) {
  var formData = new FormData();
  if (typeof file === "string" || file instanceof Buffer) {
    file = [file];
  }
  for (var _iterator = _createForOfIteratorHelperLoose(file), _step; !(_step = _iterator()).done;) {
    var f = _step.value;
    if (typeof f === "string") {
      var absoluteFilePath = resolve(f);
      var fileBuffer = readFileSync(absoluteFilePath);
      formData.append(fieldName, fileBuffer, {
        contentType: "application/octet-stream",
        filename: basename(absoluteFilePath)
      });
    } else {
      formData.append(fieldName, f, {
        contentType: "application/octet-stream",
        filename: "file." + getFileExtension(f)
      });
    }
  }
  return formData;
}
function getFile(filePath) {
  var absoluteFilePath = resolve(filePath);
  var file = readFileSync(absoluteFilePath);
  return Buffer.from(file);
}

function handleEndPoint(type, inputType, responseFormat) {
  if (inputType === "file" && responseFormat === "file") {
    return type + "/file";
  } else if (inputType === "file" && responseFormat === "url") {
    return type + "/file/url" + (type === "resize" ? "s" : "");
  } else if (inputType === "url" && responseFormat === "file") {
    return type + "/url/file";
  } else if (inputType === "url" && responseFormat === "url") {
    return type + "/file-urls";
  }
  return "";
}

function isFileOrUrl(input) {
  if (input instanceof Buffer) {
    return "file";
  } else if (input.match(/^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)/)) {
    return "url";
  } else {
    return "file";
  }
}

/**
 * Crops an image file or URL.
 *
 * @example
 *   const { imageProcessor } = require("apyhub");
 *
 *   const crop = async () => {
 *     const data = await imageProcessor.crop({
 *       responseFormat: "url",
 *       input: "https://assets.apyhub.com/samples/sample.pdf",
 *       height: 200,
 *       width: 200,
 *       output: "output.png",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the image cropping.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string | Buffer} params.input - The image file or URL to crop.
 * @param {number} params.height - The desired height of the cropped image.
 * @param {number} params.width - The desired width of the cropped image.
 * @param {string} [params.output] - The desired file name for the output
 *   cropped image.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting cropped image file or URL as a string.
 * @link https://apyhub.com/utility/image-processor-crop
 */
function crop(_x) {
  return _crop.apply(this, arguments);
}
function _crop() {
  _crop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, height, width, output, client, inputType, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, height = _ref.height, width = _ref.width, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat,
              height: height,
              width: width
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            url = "https://api.apyhub.com/processor/image/" + handleEndPoint("crop", inputType, responseFormat) + "?output=" + (output != null ? output : "output.png") + "&height=" + height + "&width=" + width;
            _context.next = 8;
            return client.request("post", url, inputType === "file" ? getFormData(input, "image") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _crop.apply(this, arguments);
}

/**
 * Resizes an image file or URL.
 *
 * @example
 *   const { imageProcessor } = require("apyhub");
 *
 *   const resize = async () => {
 *     const data = await imageProcessor.resize({
 *       responseFormat: "url",
 *       input: "https://assets.apyhub.com/samples/sample.pdf",
 *       height: 200,
 *       width: 200,
 *       output: "output.png",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the image resizing.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string | Buffer} params.input - The image file or URL to resize.
 * @param {number} params.height - The desired height of the resized image.
 * @param {number} params.width - The desired width of the resized image.
 * @param {string} [params.output] - The desired file name for the output
 *   resized image.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting resized image file or URL as a string.
 * @link https://apyhub.com/utility/image-processor-resize
 */
function resize(_x) {
  return _resize.apply(this, arguments);
}
function _resize() {
  _resize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, height, width, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, height = _ref.height, width = _ref.width, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat,
              height: height,
              width: width
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/processor/image/" + handleEndPoint("resize", inputType, responseFormat) + "?output=" + (output != null ? output : "output.png") + "&height=" + height + "&width=" + width;
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "image") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _resize.apply(this, arguments);
}

/**
 * Compresses an image file or URL.
 *
 * @example
 *   const { imageProcessor } = require("apyhub");
 *
 *   const compress = async () => {
 *     const data = await imageProcessor.compress({
 *       responseFormat: "url",
 *       input: "https://assets.apyhub.com/samples/sample.png",
 *       quality: 50,
 *       output: "compressed.png",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the image compression.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string | Buffer} params.input - The image file or URL to compress.
 * @param {number} params.quality - The desired quality of the compressed image.
 * @param {string} [params.output] - The desired file name for the output
 *   compressed image.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting compressed image file or URL as a string.
 * @link https://apyhub.com/utility/image-processor-compress
 */
function compress(_x) {
  return _compress.apply(this, arguments);
}
function _compress() {
  _compress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, quality, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, quality = _ref.quality, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat,
              quality: quality
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/processor/image/" + handleEndPoint("compress", inputType, responseFormat) + "?output=" + (output != null ? output : "output.png") + "&quality=" + quality;
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "image") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _compress.apply(this, arguments);
}

/**
 * Adds a watermark to an image.
 *
 * @example
 *   const { imageProcessor } = require("apyhub");
 *
 *   const watermark = async () => {
 *     const data = await imageProcessor.watermark({
 *       input: "https://assets.apyhub.com/samples/sample.pdf",
 *       watermark: "https://assets.apyhub.com/samples/sample.pdf",
 *       responseFormat: "url",
 *       output: "output.png",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} options - The options for the function.
 * @param {string | Buffer} options.input - The input image as a file path or
 *   URL, or as a Buffer if it is a file.
 * @param {string} options.watermark - The watermark image as a file path or
 *   URL, or as a Buffer if it is a file.
 * @param {"url" | "file"} options.responseFormat - The desired response format.
 *   Can be either "url" or "file".
 * @param {string | Buffer} [options.output] - The desired file name for the
 *   output image. Default is "output.png".
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves to
 *   an object with the watermarked image as a URL or file, or undefined if the
 *   response format is invalid.
 * @link https://apyhub.com/utility/image-processor-watermark
 */
function watermark(_x) {
  return _watermark.apply(this, arguments);
}
function _watermark() {
  _watermark = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, watermark, responseFormat, output, client, inputType, requestUrl, formData;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, watermark = _ref.watermark, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              watermark: watermark,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/processor/image/" + handleEndPoint("watermark", inputType, responseFormat) + "?output=" + (output != null ? output : "output.png");
            formData = function formData() {
              var formData = new FormData();
              formData.append("image", input instanceof Buffer ? input : getFile(input), {
                filename: "image.png",
                contentType: "application/octet-stream"
              });
              formData.append("watermark", watermark instanceof Buffer ? watermark : getFile(watermark), {
                filename: "watermark.png",
                contentType: "application/octet-stream"
              });
              return formData;
            };
            _context.next = 9;
            return client.request("post", requestUrl, inputType === "file" ? formData() : {
              imageUrl: input,
              watermarkUrl: watermark
            });
          case 9:
            return _context.abrupt("return", _context.sent);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _watermark.apply(this, arguments);
}



var index$2 = {
  __proto__: null,
  crop: crop,
  resize: resize,
  watermark: watermark,
  compress: compress
};

/**
 * Creates an archive file (zip) from a list of files or URLs.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const archive = async () => {
 *     const data = await generate.archive({
 *       responseFormat: "url",
 *       input: [
 *         "https://assets.apyhub.com/samples/sample.pdf",
 *         "https://assets.apyhub.com/samples/sample.xlsx",
 *       ],
 *     });
 *     return data;
 *   };
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const secureArchive = async () => {
 *     const data = await generate.archive({
 *       responseFormat: "url",
 *       input: [
 *         "https://assets.apyhub.com/samples/sample.pdf",
 *         "https://assets.apyhub.com/samples/sample.xlsx",
 *       ],
 *       password: "password",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the archive creation.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output
 *   archive.
 * @param {string[] | Buffer[]} params.input - The list of files or URLs to
 *   archive.
 * @param {string} [params.password] - The password to use for secure archiving.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting archive file or URL as a string.
 * @link https://apyhub.com/utility/generate-file-archive
 * @link https://apyhub.com/utility/generate-secure-file-archive
 */
function archive(_x) {
  return _archive.apply(this, arguments);
}
function _archive() {
  _archive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var responseFormat, output, input, password, client, endpoint, responseType, inputType, url, formData, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            responseFormat = _ref.responseFormat, output = _ref.output, input = _ref.input, password = _ref.password;
            client = getInstance();
            checkMissingParams({
              responseFormat: responseFormat,
              input: input
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            endpoint = password ? "secure-archive" : "archive";
            responseType = responseFormat === "file" ? "archive-file" : "archive-url";
            inputType = isFileOrUrl(input[0]) === "file" ? "files" : "file-urls";
            url = "\n    https://api.apyhub.com/generate/" + endpoint + "/" + inputType + "/" + responseType + "?output=" + (output != null ? output : "output.zip");
            formData = function formData() {
              var formData = getFormData(input, "files");
              password && formData.append("password", password);
              return formData;
            };
            data = inputType === "file-urls" ? {
              urls: input,
              password: password != null ? password : undefined
            } : formData();
            _context.next = 12;
            return client.request("post", url, data);
          case 12:
            return _context.abrupt("return", _context.sent);
          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _archive.apply(this, arguments);
}

/**
 * Generates a barcode image from a string of up to 80 characters.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const barcode = async () => {
 *     const data = await generate.barcode({
 *       responseFormat: "url",
 *       input: "https://apyhub.com",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the barcode generation.
 * @param {string & { maxLength: 80 }} params.input - The string to generate the
 *   barcode from.
 * @param {"file" | "url"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output
 *   barcode image.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting barcode image file or URL as a string.
 * @link https://apyhub.com/utility/generate-bar-code
 */
function barcode(_x) {
  return _barcode.apply(this, arguments);
}
function _barcode() {
  _barcode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            url = "https://api.apyhub.com/generate/barcode/" + responseFormat + "?output=" + (output != null ? output : "output.png");
            _context.next = 7;
            return client.request("post", url, {
              content: input
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _barcode.apply(this, arguments);
}

/**
 * Generates a QR code image from a string.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const qr = async () => {
 *     const data = await generate.qr({
 *       responseFormat: "url",
 *       input: "https://apyhub.com",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the QR code generation.
 * @param {string} params.input - The string to generate the QR code from.
 * @param {"file" | "url"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output QR
 *   code image.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting QR code image file or URL as a string.
 * @link https://apyhub.com/utility/generate-qr-code
 */
function qr(_x) {
  return _qr.apply(this, arguments);
}
function _qr() {
  _qr = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            url = "https://api.apyhub.com/generate/qr-code/" + responseFormat + "?output=" + (output != null ? output : "output.png");
            _context.next = 7;
            return client.request("post", url, {
              content: input
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _qr.apply(this, arguments);
}

/**
 * Takes a screenshot of a webpage.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const screenshot = async () => {
 *     const data = await generate.screenshot({
 *       responseFormat: "url",
 *       input: "https://apyhub.com",
 *       delay: 5,
 *       quality: 3,
 *       output: "screenshot.png",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the screenshot generation.
 * @param {string} params.input - The URL of the webpage to take a screenshot
 *   of.
 * @param {string} [params.output] - The desired file name for the output
 *   screenshot image.
 * @param {number} [params.delay] - The delay, in seconds, before taking the
 *   screenshot.
 * @param {1 | 2 | 3 | 4 | 5} [params.quality] - The quality of the screenshot
 *   image.
 * @param {"file" | "url"} params.responseFormat - The desired response format.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting screenshot image file or URL as a string.
 * @link https://apyhub.com/utility/generate-webpage-screenshot
 */
function screenshot(_x) {
  return _screenshot.apply(this, arguments);
}
function _screenshot() {
  _screenshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, output, delay, quality, responseFormat, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, output = _ref.output, delay = _ref.delay, quality = _ref.quality, responseFormat = _ref.responseFormat;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            quality && checkParamTypes({
              quality: quality == null ? void 0 : quality.toString()
            }, [1, 2, 3, 4, 5].map(function (i) {
              return i.toString();
            }));
            url = "\n        https://api.apyhub.com/generate/screenshot/webpage/image-" + responseFormat + "?output=" + (output != null ? output : "output.png") + "&delay=" + (delay != null ? delay : 3) + "&quality=" + (quality != null ? quality : 5) + "&url=" + input;
            _context.next = 8;
            return client.request("get", url);
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _screenshot.apply(this, arguments);
}

/**
 * Generates a chart image from data and chart options.
 *
 * @example
 *   const { charts } = require("apyhub");
 *
 *   const data = [
 *     { value: 10, label: "A" },
 *     { value: 20, label: "B" },
 *     { value: 30, label: "C" },
 *     { value: 40, label: "D" },
 *   ];
 *
 *   charts({
 *     responseFormat: "file",
 *     chartType: "bar",
 *     output: "chart.png",
 *     title: "My Chart",
 *     theme: "light",
 *     data,
 *   }).then((res) => {
 *     console.log(res);
 *   });
 *
 * @param {Object} options - The options object.
 * @param {"file" | "url"} options.responseFormat - The format in which the
 *   chart should be returned. Valid values are "url" or "file".
 * @param {"bar" | "pie" | "stacked"} options.chartType - The type of chart to
 *   generate. Valid values are "bar", "pie" or "stacked".
 * @param {string} [options.output] - The file path where the chart should be
 *   saved. This parameter is only used if responseFormat is "file".
 * @param {string} [options.title] - The title of the chart.
 * @param {"light" | "dark"} [options.theme] - The theme of the chart. Valid
 *   values are "light" or "dark".
 * @param {{ value: number; label: string }[]} options.data - The data to be
 *   used to generate the chart.
 * @returns {Promise<{ data: string }>} A promise that resolves with the chart
 *   data if successful.
 * @link https://apyhub.com/utility/pie-chart
 * @link https://apyhub.com/utility/stacked-graph
 * @link https://apyhub.com/utility/bar-graph
 */
function charts(_x) {
  return _charts.apply(this, arguments);
}
function _charts() {
  _charts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var responseFormat, chartType, output, title, theme, data, client, url, payload;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            responseFormat = _ref.responseFormat, chartType = _ref.chartType, output = _ref.output, title = _ref.title, theme = _ref.theme, data = _ref.data;
            client = getInstance();
            checkMissingParams({
              responseFormat: responseFormat,
              chartType: chartType,
              data: data
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            checkParamTypes({
              chartType: chartType
            }, ["bar", "pie", "stacked"]);
            theme && checkParamTypes({
              theme: theme
            }, ["light", "dark"]);
            url = "https://api.apyhub.com/generate/charts/" + chartType + "/" + responseFormat + "?output=" + (output != null ? output : "output.png");
            payload = _extends({}, title && {
              title: title
            }, theme && {
              theme: theme[0].toUpperCase() + theme.slice(1)
            }, {
              data: data
            });
            _context.next = 10;
            return client.request("post", url, payload);
          case 10:
            return _context.abrupt("return", _context.sent);
          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _charts.apply(this, arguments);
}

/**
 * Generates a PDF file from an HTML string or URL.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const pdf = async () => {
 *     const data = await generate.pdf({
 *       responseFormat: "url",
 *       input: "https://apyhub.com",
 *       landscape: true,
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the PDF generation.
 * @param {string} params.input - The HTML string or URL to generate the PDF
 *   from.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {boolean} [params.landscape] - Whether to generate the PDF in
 *   landscape orientation.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting PDF file or URL as a string.
 * @link https://apyhub.com/utility/generate-url-pdf
 * @link https://apyhub.com/utility/generate-html-pdf
 */
function pdf(_x) {
  return _pdf.apply(this, arguments);
}
function _pdf() {
  _pdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var _client$request;
    var input, responseFormat, landscape, client, isUrl, inputType, inputField, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, landscape = _ref.landscape;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            // check if input string is valid url without using isFileOrUrl
            // TODO - move this to utils refactor isFileOrUrl to use this
            isUrl = function isUrl(url) {
              try {
                var isValid = new URL(url);
                return !!isValid;
              } catch (error) {
                return false;
              }
            };
            inputType = isUrl(input) ? "webpage" : "html-content";
            inputField = isUrl(input) ? "url" : "content";
            url = "https://api.apyhub.com/generate/" + inputType + "/pdf-" + responseFormat + "?&landscape=" + (landscape === true ? "true" : "false");
            console.log(url);
            _context.next = 11;
            return client.request("post", url, (_client$request = {}, _client$request[inputField] = input, _client$request));
          case 11:
            return _context.abrupt("return", _context.sent);
          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _pdf.apply(this, arguments);
}

/**
 * Generates an iCalendar file from a list of parameters.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const ical = async () => {
 *   const data = await generate.ical({
 *   responseFormat: "url",
 *   summary: "Meeting",
 *   description: "Meeting description",
 *   organizerEmail: "your@mail.com",
 *   attendeesEmails: ["john@mail.com", "sally@mail.com"],
 *   timeZone: "America/New_York",
 *   startTime: "10:00",
 *   endTime: "11:00",
 *   meetingDate: "2020-01-01",
 *   recurring: true,
 *   recurrence: {
 *   frequency: "WEEKLY",
 *   count: 5,
 *   },
 *   });
 *   return data;
 *
 * @param {Object} params - The parameters for the iCalendar file generation.
 * @param {"file" | "url"} params.responseFormat - The desired response format.
 * @param {string} params.summary - The meeting summary.
 * @param {string} params.description - The meeting description.
 * @param {string} params.organizerEmail - The meeting organizer's email
 *   address.
 * @param {string[]} params.attendeesEmails - The meeting attendees' email
 *   addresses.
 * @param {string} [params.location] - The meeting location.
 * @param {string} params.timeZone - The meeting time zone.
 * @param {string} params.startTime - The meeting start time.
 * @param {string} params.endTime - The meeting end time.
 * @param {string} params.meetingDate - The meeting date.
 * @param {boolean} params.recurring - Whether the meeting is recurring.
 * @param {Object} [params.recurrence] - The meeting recurrence parameters.
 * @param {string} [params.recurrence.frequency] - The meeting recurrence
 *   frequency.
 * @param {number} [params.recurrence.count] - The meeting recurrence count.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting iCalendar file or URL as a string.
 * @link https://apyhub.com/utility/generator-ical
 */
function ical(_x) {
  return _ical.apply(this, arguments);
}
function _ical() {
  _ical = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var output, responseFormat, summary, description, organizerEmail, attendeesEmails, location, timeZone, startTime, endTime, meetingDate, recurring, recurrence, client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            output = _ref.output, responseFormat = _ref.responseFormat, summary = _ref.summary, description = _ref.description, organizerEmail = _ref.organizerEmail, attendeesEmails = _ref.attendeesEmails, location = _ref.location, timeZone = _ref.timeZone, startTime = _ref.startTime, endTime = _ref.endTime, meetingDate = _ref.meetingDate, recurring = _ref.recurring, recurrence = _ref.recurrence;
            client = getInstance();
            checkMissingParams({
              responseFormat: responseFormat,
              summary: summary,
              description: description,
              organizerEmail: organizerEmail,
              attendeesEmails: attendeesEmails,
              timeZone: timeZone,
              startTime: startTime,
              endTime: endTime,
              meetingDate: meetingDate
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            url = "https://api.apyhub.com/generate/ical/" + responseFormat + "?output=" + (output != null ? output : "invite.ics");
            _context.next = 7;
            return client.request("post", url, {
              summary: summary,
              description: description,
              organizer_email: organizerEmail,
              attendees_email: attendeesEmails,
              location: location,
              time_zone: timeZone,
              start_time: startTime,
              end_time: endTime,
              meeting_date: meetingDate,
              recurring: recurring,
              recurrence: recurrence
            });
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _ical.apply(this, arguments);
}

/**
 * Creates a thumbnail image from a file or URL.
 *
 * @example
 *   const { generate } = require("apyhub");
 *
 *   const thumbnail = async () => {
 *     const data = await generate.thumbnail({
 *       responseFormat: "url",
 *       input: "https://assets.apyhub.com/samples/sample.pdf",
 *       width: 200,
 *       height: 200,
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the thumbnail creation.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output
 *   thumbnail.
 * @param {string | Buffer} params.input - The file or URL to create a thumbnail
 *   from.
 * @param {number} params.width - The desired width of the thumbnail.
 * @param {number} params.height - The desired height of the thumbnail.
 * @returns {Promise<{ data: string }>} - A promise that resolves with an object
 *   containing the resulting thumbnail file or URL as a string.
 * @link https://apyhub.com/utility/image-processor-thumbnail
 */
function thumbnail(_x) {
  return _thumbnail.apply(this, arguments);
}
function _thumbnail() {
  _thumbnail = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, width, height, client, inputType, endpoint, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output, width = _ref.width, height = _ref.height;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat,
              width: width,
              height: height
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            endpoint = "";
            if (inputType === "file" && responseFormat === "file") {
              endpoint = "file";
            } else if (inputType === "file" && responseFormat === "url") {
              endpoint = "file/url";
            } else if (inputType === "url" && responseFormat === "file") {
              endpoint = "url/file";
            } else if (inputType === "url" && responseFormat === "url") {
              endpoint = "file-urls";
            }
            requestUrl = "https://api.apyhub.com/generate/image/thumbnail/" + endpoint + "?output=" + (output != null ? output : "thumbnail.png") + "&width=" + width + "&height=" + height;
            _context.next = 10;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "image") : {
              url: input
            });
          case 10:
            return _context.abrupt("return", _context.sent);
          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _thumbnail.apply(this, arguments);
}



var index$3 = {
  __proto__: null,
  archive: archive,
  barcode: barcode,
  qr: qr,
  screenshot: screenshot,
  charts: charts,
  pdf: pdf,
  ical: ical,
  thumbnail: thumbnail
};

/**
 * Extracts text from a webpage.
 *
 * @example
 *   const { extract } = require("apyhub");
 *
 *   const textFromWebpage = async () => {
 *     const data = await extract.textFromWebpage("https://www.apyhub.com");
 *     return data;
 *   };
 *
 * @param {string} url - The URL of the webpage.
 * @returns {Promise<{ data: string }>} A promise that resolves to the text for
 *   the webpage.
 * @link https://apyhub.com/utility/extractor-webpage-text
 */
function textFromWebpage(_x) {
  return _textFromWebpage.apply(this, arguments);
}
function _textFromWebpage() {
  _textFromWebpage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {
    var client, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            checkMissingParams({
              url: url
            });
            requestUrl = "https://api.apyhub.com/extract/text/webpage?url=" + url;
            _context.next = 5;
            return client.request("get", requestUrl);
          case 5:
            return _context.abrupt("return", _context.sent);
          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _textFromWebpage.apply(this, arguments);
}

/**
 * Extracts text from a Word document.
 *
 * @example
 *   const { extract } = require("apyhub");
 *
 *   const textFromWord = async () => {
 *     const data = await extract.textFromWord(
 *       "https://assets.apyhub.com/samples/sample.docx"
 *     );
 *     return data;
 *   };
 *
 * @param {string | Buffer} word - The Word document file or URL.
 * @returns {Promise<{ data: string }>} A promise that resolves to the text for
 *   the Word document.
 * @link https://apyhub.com/utility/extractor-word-text
 */
function textFromWord(_x) {
  return _textFromWord.apply(this, arguments);
}
function _textFromWord() {
  _textFromWord = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(word) {
    var client, inputType, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            checkMissingParams({
              word: word
            });
            inputType = isFileOrUrl(word) === "file" ? "file" : "url";
            url = "https://api.apyhub.com/extract/text/word-" + inputType;
            _context.next = 6;
            return client.request("post", url, inputType === "file" ? getFormData(word, "file") : {
              url: word
            });
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _textFromWord.apply(this, arguments);
}

/**
 * Extracts text from a PDF file.
 *
 * @example
 *   const { extract } = require("apyhub");
 *
 *   const textFromPdf = async () => {
 *     const data = await extract.textFromPdf(
 *       "https://assets.apyhub.com/samples/sample.pdf"
 *     );
 *     return data;
 *   };
 *
 * @param {string | Buffer} pdf - The PDF file or URL.
 * @returns {Promise<{ data: string }>} A promise that resolves to the text for
 *   the PDF.
 * @link https://apyhub.com/utility/extractor-pdf-text
 */
function textFromPdf(_x) {
  return _textFromPdf.apply(this, arguments);
}
function _textFromPdf() {
  _textFromPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(pdf) {
    var client, inputType, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            checkMissingParams({
              pdf: pdf
            });
            inputType = isFileOrUrl(pdf) === "file" ? "file" : "url";
            url = "https://api.apyhub.com/extract/text/pdf-" + inputType;
            _context.next = 6;
            return client.request("post", url, inputType === "file" ? getFormData(pdf, "file") : {
              url: pdf
            });
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _textFromPdf.apply(this, arguments);
}

/**
 * Extracts metadata from an image.
 *
 * @example
 *   const { extract } = require("apyhub");
 *
 *   const imageMetadata = async () => {
 *     const data = await extract.imageMetadata(
 *       "https://assets.apyhub.com/samples/sample.jpg"
 *     );
 *     return data;
 *   };
 *
 * @param {string | Buffer} image - The image file or URL.
 * @returns {Promise<{ data: string }>} A promise that resolves to the metadata
 *   for the image.
 * @link https://apyhub.com/utility/image-processor-extract-metadata
 */
function imageMetadata(_x) {
  return _imageMetadata.apply(this, arguments);
}
function _imageMetadata() {
  _imageMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(image) {
    var client, inputType, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            checkMissingParams({
              image: image
            });
            inputType = isFileOrUrl(image) === "file" ? "file" : "file-urls"; // const contentType =
            //   inputType === "file" ? "multipart/form-data" : "application/json";
            url = "https://api.apyhub.com/processor/image/metadata/" + inputType;
            _context.next = 6;
            return client.request("post", url, inputType === "file" ? getFormData(image, "image") : {
              url: image
            }
            // { headers: { "Content-Type": contentType } }
            );
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _imageMetadata.apply(this, arguments);
}

/**
 * Extracts the contents of an archive file (zip) to a list of files or URLs.
 * @example
 *
 * const { extract } = require("apyhub");
 *
 * const unarchive = async () => {
 *  const data = await extract.unarchive({
 *   input: "https://assets.apyhub.com/samples/sample.zip",
 * });
 * return data;
 * };
 *
 * @param {Object} params - The parameters for the archive extraction.
 * @param {string | Buffer} params.input - The archive file or URL to extract.
 * @param {string} [params.password] - The password to use for secure extraction.
 *
 * @returns {Promise<{ data: Buffer }>} - A promise that resolves with an object containing the resulting extracted files or URLs as a Buffer.
 *
 * @link https://apyhub.com/utility/extract-file-unarchive
 * @link https://apyhub.com/utility/extract-file-secure-unarchive
 */
function unarchive(_x) {
  return _unarchive.apply(this, arguments);
}
function _unarchive() {
  _unarchive = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, password, client, inputType, url, formData, data;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, password = _ref.password;
            client = getInstance();
            checkMissingParams({
              input: input
            });
            inputType = isFileOrUrl(input) === "file" ? "file" : "url";
            url = "https://api.apyhub.com/extract/" + (password ? "secure-archive" : "archive") + "/" + inputType + "/file-urls";
            formData = function formData() {
              var formData = getFormData(input, "file");
              password && formData.append("password", password);
              return formData;
            };
            data = inputType === "url" ? {
              urls: input,
              password: password != null ? password : undefined
            } : formData();
            _context.next = 9;
            return client.request("post", url, data);
          case 9:
            return _context.abrupt("return", _context.sent);
          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _unarchive.apply(this, arguments);
}



var index$4 = {
  __proto__: null,
  textFromWebpage: textFromWebpage,
  textFromWord: textFromWord,
  textFromPdf: textFromPdf,
  imageMetadata: imageMetadata,
  unarchive: unarchive
};

/**
 * Retrieves a list of countries and their associated data.
 *
 * @example
 *   import { data } from "apyhub";
 *
 *   const countries = async () => {
 *     const data = await data.countries();
 *     return data;
 *   };
 *
 * @returns {Promise<
 *   {
 *     calling_codes: number[];
 *     cca3: string;
 *     emoji: string;
 *     key: string;
 *     value: string;
 *   }[]
 * >}
 *   - A promise that resolves with an array of country objects, each containing
 *       calling codes, cca3 code, emoji, key, and value properties.
 *
 * @link https://apyhub.com/utility/data-lists-country
 */
function countries() {
  return _countries.apply(this, arguments);
}
function _countries() {
  _countries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            url = "https://api.apyhub.com/data/dictionary/country";
            _context.next = 4;
            return client.request("get", url);
          case 4:
            return _context.abrupt("return", _context.sent);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _countries.apply(this, arguments);
}

/**
 * Retrieves information about a specific country.
 *
 * @example
 *   import { data } from "apyhub";
 *
 *   const country = () async => {
 *   const data = await data.country("United States");
 *   return data;
 *   }
 *
 * @param {string} country - The name or cca3 code of the country.
 * @returns {Promise<{
 *   value: string;
 *   key: string;
 *   cca3: string;
 *   emoji: string;
 *   calling_code: number[];
 *   subdivision: { code: string; name: string }[];
 * }>}
 *   - A promise that resolves with an object containing the country's value, key,
 *       cca3 code, emoji, calling codes, and an array of subdivisions, each
 *       with a code and name.
 *
 * @link https://apyhub.com/utility/data-info-country
 */
function country(_x) {
  return _country.apply(this, arguments);
}
function _country() {
  _country = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(country) {
    var client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            if (country) {
              _context.next = 3;
              break;
            }
            throw new Error("Missing country");
          case 3:
            url = "https://api.apyhub.com/data/info/country?country=" + country;
            _context.next = 6;
            return client.request("get", url);
          case 6:
            return _context.abrupt("return", _context.sent);
          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _country.apply(this, arguments);
}

/**
 * Converts an amount in one currency to another.
 *
 * @example
 *   import { data } from "apyhub";
 *
 *   const currencyConverter = async () => {
 *     const response = await data.currencyConverter({
 *       source: "USD",
 *       target: "EUR",
 *       date: "2021-01-01",
 *     });
 *     return response;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string} params.source - The source currency.
 * @param {string} params.target - The target currency.
 * @param {string} [params.date] - The date for the conversion (in the format
 *   "YYYY-MM-DD"). If not provided, the current date is used.
 * @returns {Promise<{ data: number }>} - A promise that resolves with an object
 *   containing the converted amount.
 * @link https://apyhub.com/utility/currency-conversion
 */
function currencyConverter(_x) {
  return _currencyConverter.apply(this, arguments);
}
function _currencyConverter() {
  _currencyConverter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var source, target, date, client, url, body;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            source = _ref.source, target = _ref.target, date = _ref.date;
            client = getInstance();
            checkMissingParams({
              source: source,
              target: target
            });
            url = "https://api.apyhub.com/data/convert/currency";
            body = {
              source: source.toLowerCase(),
              target: target.toLowerCase(),
              date: date
            };
            _context.next = 7;
            return client.request("post", url, body);
          case 7:
            return _context.abrupt("return", _context.sent);
          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _currencyConverter.apply(this, arguments);
}

/**
 * Retrieves a list of currencies and their associated data.
 *
 * @example
 *   import { data } from "apy-client";
 *
 *   const currencyList = async () => {
 *     const data = await data.currencyList();
 *     return data;
 *   };
 *
 * @returns {Promise<
 *   {
 *     calling_codes: number[];
 *     cca3: string;
 *     emoji: string;
 *     key: string;
 *     value: string;
 *   }[]
 * >}
 *   - A promise that resolves with an array of currency objects, each containing
 *       calling codes, cca3 code, emoji, key, and value properties.
 *
 * @link https://apyhub.com/utility/data-lists-currency
 */
function currencyList() {
  return _currencyList.apply(this, arguments);
}
function _currencyList() {
  _currencyList = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            url = "https://api.apyhub.com/data/dictionary/currency";
            _context.next = 4;
            return client.request("get", url);
          case 4:
            return _context.abrupt("return", _context.sent);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _currencyList.apply(this, arguments);
}

/**
 * Retrieves a list of timezones and their associated data.
 *
 * @example
 *   import { data } from "apy-client";
 *
 *   const timezones = async () => {
 *     const data = await data.timezones();
 *     return data;
 *   };
 *
 * @returns {Promise<{
 *   data: {
 *     key: string;
 *     value: string;
 *     abbreviation: string[];
 *     utc_time: string;
 *   }[];
 * }>}
 *   - A promise that resolves with an object containing an array of timezone
 *       objects, each with a key, value, abbreviation, and utc_time property.
 *
 * @link https://apyhub.com/utility/data-lists-timezone
 */
function timezones() {
  return _timezones.apply(this, arguments);
}
function _timezones() {
  _timezones = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    var client, url;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            client = getInstance();
            url = "https://api.apyhub.com/data/dictionary/timezone";
            _context.next = 4;
            return client.request("get", url);
          case 4:
            return _context.abrupt("return", _context.sent);
          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _timezones.apply(this, arguments);
}



var index$5 = {
  __proto__: null,
  countries: countries,
  country: country,
  currencyConverter: currencyConverter,
  currencyList: currencyList,
  timezones: timezones
};

function handleEndPointConvert(input, output, inputType, responseFormat) {
  if (inputType === "file" && responseFormat === "file") {
    return input + "-file/" + output + "-file";
  } else if (inputType === "file" && responseFormat === "url") {
    return input + "-file/" + output + "-url";
  } else if (inputType === "url" && responseFormat === "file") {
    return input + "-url/" + output + "-file";
  } else if (inputType === "url" && responseFormat === "url") {
    return input + "-url/" + output + "-url";
  }
  return "";
}

/**
 * Converts a CSV file or URL to an Excel file.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const csvToExcel = async () => {
 *     const data = await convert.csvToExcel({
 *       input: "https://assets.apyhub.com/samples/sample.csv",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The CSV file or URL.
 * @param {"url" | "file"} params.responseFormat - The format for the response.
 * @param {string} [params.output] - The name for the output Excel file.
 * @returns {Promise<{ data: string } | undefined>} A promise that resolves to
 *   the data for the output file or `undefined` if the response format is not
 *   "url".
 * @link https://apyhub.com/utility/converter-csv-excel
 */
function csvToExcel(_x) {
  return _csvToExcel.apply(this, arguments);
}
function _csvToExcel() {
  _csvToExcel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("csv", "excel", inputType, responseFormat) + "?output=" + (output != null ? output : "output.xlsx");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _csvToExcel.apply(this, arguments);
}

/**
 * Converts an HTML file or URL to a PDF file.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const htmlToPdf = async () => {
 *     const data = await convert.htmlToPdf({
 *       input: "https://assets.apyhub.com/samples/sample.html",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The HTML file or URL.
 * @param {"url" | "file"} params.responseFormat - The format for the response.
 * @param {string} [params.output] - The name for the output PDF file.
 * @returns {Promise<{ data: string } | undefined>} A promise that resolves to
 *   the data for the output file or `undefined` if the response format is not
 *   "url".
 * @link https://apyhub.com/utility/converter-html-pdf
 */
function htmlToPdf(_x) {
  return _htmlToPdf.apply(this, arguments);
}
function _htmlToPdf() {
  _htmlToPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("html", "pdf", inputType, responseFormat) + "?output=" + (output != null ? output : "output.pdf");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _htmlToPdf.apply(this, arguments);
}

/**
 * Converts an image file or URL to a PDF file.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const imageToPdf = async () => {
 *     const data = await convert.imageToPdf({
 *       input: "https://assets.apyhub.com/samples/sample.jpg",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The image file or URL.
 * @param {"url" | "file"} params.responseFormat - The format for the response.
 * @param {string} [params.output] - The name for the output PDF file.
 * @returns {Promise<{ data: string } | undefined>} A promise that resolves to
 *   the data for the output file or `undefined` if the response format is not
 *   "url".
 * @link https://apyhub.com/utility/converter-image-pdf
 */
function imageToPdf(_x) {
  return _imageToPdf.apply(this, arguments);
}
function _imageToPdf() {
  _imageToPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("image", "pdf", inputType, responseFormat) + "?output=" + (output != null ? output : "output.pdf");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _imageToPdf.apply(this, arguments);
}

/**
 * Convert markdown to HTML.
 *
 * This function converts the given markdown input to HTML and returns the
 * result.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const markdownToHtml = async () => {
 *     const data = await convert.markdownToHtml({
 *       input: "# Hello World",
 *       responseFormat: "url",
 *     });
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The markdown input.
 * @param {"url" | "file"} params.responseFormat - The format of the response.
 *   Can be "url" or "file".
 * @param {string} [params.output] - The name of the output file.
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves
 *   with the HTML output.
 * @link https://apyhub.com/utility/converter-md-html
 */
function markdownToHtml(_x) {
  return _markdownToHtml.apply(this, arguments);
}
function _markdownToHtml() {
  _markdownToHtml = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("md", "html", inputType, responseFormat) + "?output=" + (output != null ? output : "output.html");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _markdownToHtml.apply(this, arguments);
}

/**
 * Convert a presentation to PDF.
 *
 * This function converts the given presentation input to PDF and returns the
 * result.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const presentationToPdf = async () => {
 *     const data = await convert.presentationToPdf({
 *       input: "https://assets.apyhub.com/samples/sample.pptx",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The presentation input.
 * @param {"url" | "file"} params.responseFormat - The format of the response.
 *   Can be "url" or "file".
 * @param {string} [params.output] - The name of the output file.
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves
 *   with the PDF output.
 * @link https://apyhub.com/utility/converter-presentation-pdf
 */
function presentationToPdf(_x) {
  return _presentationToPdf.apply(this, arguments);
}
function _presentationToPdf() {
  _presentationToPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("presentation", "pdf", inputType, responseFormat) + "?output=" + (output != null ? output : "output.pdf");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _presentationToPdf.apply(this, arguments);
}

/**
 * Converts a spreadsheet file or URL to a PDF file.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const spreadsheetToPdf = async () => {
 *     const data = await convert.spreadsheetToPdf({
 *       input: "https://assets.apyhub.com/samples/sample.xlsx",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The file or URL to convert.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output PDF.
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves
 *   with the resulting PDF file or URL as a string, or undefined if the
 *   conversion failed.
 * @link https://apyhub.com/utility/converter-spreadsheet-pdf
 */
function spreadsheetToPdf(_x) {
  return _spreadsheetToPdf.apply(this, arguments);
}
function _spreadsheetToPdf() {
  _spreadsheetToPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("spreadsheet", "pdf", inputType, responseFormat) + "?output=" + (output != null ? output : "output.pdf");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _spreadsheetToPdf.apply(this, arguments);
}

/**
 * Converts a Word file or URL to a PDF file.
 *
 * @example
 *   const { convert } = require("apyhub");
 *
 *   const wordToPdf = async () => {
 *     const data = await convert.wordToPdf({
 *       input: "https://assets.apyhub.com/samples/sample.docx",
 *       responseFormat: "url",
 *     });
 *     return data;
 *   };
 *
 * @param {Object} params - The parameters for the conversion.
 * @param {string | Buffer} params.input - The file or URL to convert.
 * @param {"url" | "file"} params.responseFormat - The desired response format.
 * @param {string} [params.output] - The desired file name for the output PDF.
 * @returns {Promise<{ data: string } | undefined>} - A promise that resolves
 *   with the resulting PDF file or URL as a string, or undefined if the
 *   conversion failed.
 * @link https://apyhub.com/utility/converter-doc-pdf
 */
function wordToPdf(_x) {
  return _wordToPdf.apply(this, arguments);
}
function _wordToPdf() {
  _wordToPdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {
    var input, responseFormat, output, client, inputType, requestUrl;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            input = _ref.input, responseFormat = _ref.responseFormat, output = _ref.output;
            client = getInstance();
            checkMissingParams({
              input: input,
              responseFormat: responseFormat
            });
            checkParamTypes({
              responseFormat: responseFormat
            }, ["file", "url"]);
            inputType = isFileOrUrl(input);
            requestUrl = "https://api.apyhub.com/convert/" + handleEndPointConvert("word", "pdf", inputType, responseFormat) + "?output=" + (output != null ? output : "output.pdf");
            _context.next = 8;
            return client.request("post", requestUrl, inputType === "file" ? getFormData(input, "file") : {
              url: input
            });
          case 8:
            return _context.abrupt("return", _context.sent);
          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _wordToPdf.apply(this, arguments);
}



var index$6 = {
  __proto__: null,
  csvToExcel: csvToExcel,
  htmlToPdf: htmlToPdf,
  imageToPdf: imageToPdf,
  markdownToHtml: markdownToHtml,
  presentationToPdf: presentationToPdf,
  spreadsheetToPdf: spreadsheetToPdf,
  wordToPdf: wordToPdf
};

function isValidUrl(url) {
  try {
    var isValid = new URL(url);
    return !!isValid;
  } catch (error) {
    return false;
  }
}
/**
 * Downloads data to the specified file path.
 *
 * @param {| Blob
 *   | string
 *   | {
 *       data: string;
 *       type?: string;
 *       arrayBuffer?: () => Promise<ArrayBuffer>;
 *     }} data
 *   - The data to download. Can be a Blob, a string, or an object with a `data`
 *       property and optionally a `type` property and an `arrayBuffer` function
 *       that returns a Promise for an ArrayBuffer.
 *
 * @param {string} filePath - The file path to save the downloaded data to.
 * @returns {Promise<void>} A Promise that resolves when the download is
 *   complete.
 * @throws {Error} If the data is invalid or there is an error writing the file.
 */
// TODO : fix this type for data
// | Blob
//     | string
//     | { data: string; type?: string; arrayBuffer?: () => Promise<ArrayBuffer> }
function download(_x, _x2) {
  return _download.apply(this, arguments);
}
function _download() {
  _download = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(data, filePath) {
    var buffer, response;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            buffer = Buffer.alloc(0);
            if (!(typeof data === "string")) {
              _context.next = 5;
              break;
            }
            buffer = Buffer.from(data);
            _context.next = 37;
            break;
          case 5:
            if (!(typeof data === "object" && data.data)) {
              _context.next = 28;
              break;
            }
            if (!isValidUrl(data.data)) {
              _context.next = 17;
              break;
            }
            _context.next = 9;
            return fetch(data.data);
          case 9:
            response = _context.sent;
            _context.t0 = Buffer;
            _context.next = 13;
            return response.arrayBuffer();
          case 13:
            _context.t1 = _context.sent;
            buffer = _context.t0.from.call(_context.t0, _context.t1);
            _context.next = 26;
            break;
          case 17:
            if (!(typeof data.data === "string")) {
              _context.next = 21;
              break;
            }
            buffer = Buffer.from(data.data);
            _context.next = 26;
            break;
          case 21:
            if (!("data" in data && typeof data.data === "object")) {
              _context.next = 25;
              break;
            }
            buffer = Buffer.from(JSON.stringify(data.data));
            _context.next = 26;
            break;
          case 25:
            throw new Error("Invalid data.data");
          case 26:
            _context.next = 37;
            break;
          case 28:
            if (!(typeof data === "object" && data.type && typeof data.arrayBuffer === "function")) {
              _context.next = 36;
              break;
            }
            _context.t2 = Buffer;
            _context.next = 32;
            return data.arrayBuffer();
          case 32:
            _context.t3 = _context.sent;
            buffer = _context.t2.from.call(_context.t2, _context.t3);
            _context.next = 37;
            break;
          case 36:
            throw new Error("Invalid data");
          case 37:
            writeFile(filePath, buffer, function (err) {
              if (err) {
                throw err;
              }
            });
          case 38:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _download.apply(this, arguments);
}

export { archive, barcode, charts, compress, index$6 as convert, countries, country, crop, csvToExcel, currencyConverter, currencyList, index$5 as data, download, email, index$4 as extract, fuzzy, index$3 as generate, htmlToPdf, ical, imageMetadata, index$2 as imageProcessor, imageToPdf, initApyhub, markdownToHtml, pdf, postcode, presentationToPdf, qr, resize, screenshot, index as search, spreadsheetToPdf, textFromPdf, textFromWebpage, textFromWord, thumbnail, timezones, unarchive, index$1 as validate, watermark, wordToPdf };
//# sourceMappingURL=apyhub.esm.js.map
